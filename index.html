<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Street Light Monitor (Leaflet + ThingSpeak)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; }
    header { padding:10px 16px; background:#0b5cff; color:white; display:flex; gap:12px; align-items:center; }
    header h1 { font-size:18px; margin:0; }
    #info { margin-left:auto; font-size:13px; opacity:.95; }
    #map { height:calc(100vh - 56px); width:100%; }
    .status-box { padding:6px 10px; background:rgba(255,255,255,0.92); border-radius:6px; box-shadow:0 1px 4px rgba(0,0,0,.12); }
    .small { font-size:13px; color:#333; }
  </style>
</head>
<body>
  <header>
    <h1>Street Light Fault Monitor</h1>
    <div class="status-box small" id="statustext">Loading latest data…</div>
    <div id="info" class="small">Last update: —</div>
  </header>

  <div id="map"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>
  /*************************************************************************
   * Configuration - EDIT THESE
   *************************************************************************/
  const THINGSPEAK_CHANNEL_ID = "3143341";       // <<-- REPLACE with your ThingSpeak Channel ID (number)
  // Field mapping used by the ESP32:
  // field1 = latitude, field2 = longitude, field3 = status (ON/OFF/FAULT), field4 = color (green/red/blue)
  // If you used different fields, update the indices below:
  const FIELD_LAT = "field1";
  const FIELD_LON = "field2";
  const FIELD_STATUS = "field3";
  const FIELD_COLOR = "field4";

  const UPDATE_INTERVAL_MS = 5000; // poll ThingSpeak every 5s (ThingSpeak rate limit ~ 15s for free, keep safe)
  // NOTE: for free ThingSpeak accounts you should set update interval >= 15s in your ESP32 code.
  /*************************************************************************/

  if (!THINGSPEAK_CHANNEL_ID || THINGSPEAK_CHANNEL_ID === "3143341") {
    alert("Please edit index.html and set THINGSPEAK_CHANNEL_ID to your channel ID before publishing.");
  }

  // Map initialization (center default somewhere until we get data)
  const defaultLat = 19.467960;
  const defaultLon = 72.888108;
  const map = L.map('map').setView([defaultLat, defaultLon], 16);

  // OpenStreetMap tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '© OpenStreetMap'
  }).addTo(map);

  // Colored marker icons (from github repo)
  const ICON_BASE = "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/";
  const ICONS = {
    green: L.icon({ iconUrl: ICON_BASE + "marker-icon-green.png", shadowUrl: ICON_BASE + "marker-shadow.png", iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34] }),
    red:   L.icon({ iconUrl: ICON_BASE + "marker-icon-red.png",   shadowUrl: ICON_BASE + "marker-shadow.png", iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34] }),
    blue:  L.icon({ iconUrl: ICON_BASE + "marker-icon-blue.png",  shadowUrl: ICON_BASE + "marker-shadow.png", iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34] }),
    grey:  L.icon({ iconUrl: ICON_BASE + "marker-icon-grey.png",  shadowUrl: ICON_BASE + "marker-shadow.png", iconSize:[25,41], iconAnchor:[12,41], popupAnchor:[1,-34] })
  };

  let marker = null;

  // Helper: sanitize color string
  function normalizeColor(raw) {
    if (!raw) return "grey";
    raw = raw.toString().trim().toLowerCase();
    if (raw.includes("green") || raw === "on") return "green";
    if (raw.includes("red") || raw === "fault") return "red";
    if (raw.includes("blue") || raw === "off") return "blue";
    return raw in ICONS ? raw : "grey";
  }

  // Pull latest feed from ThingSpeak
  async function fetchLatest() {
    try {
      const url = `https://api.thingspeak.com/channels/${THINGSPEAK_CHANNEL_ID}/feeds/last.json`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();

      // ThingSpeak returns fields with keys field1, field2, ...
      const latRaw = data[FIELD_LAT];
      const lonRaw = data[FIELD_LON];
      const statusRaw = data[FIELD_STATUS];
      const colorRaw = data[FIELD_COLOR];

      const lat = parseFloat(latRaw);
      const lon = parseFloat(lonRaw);
      const status = statusRaw ? statusRaw.toString() : "—";
      const color = normalizeColor(colorRaw || statusRaw);

      // Update UI
      const now = new Date();
      document.getElementById("info").textContent = "Last update: " + now.toLocaleString();
      document.getElementById("statustext").innerHTML = `<strong>Status:</strong> ${status} &nbsp; <strong>Color:</strong> ${color}`;

      // Validate coordinates
      if (!isFinite(lat) || !isFinite(lon)) {
        console.warn("Invalid lat/lon from ThingSpeak:", latRaw, lonRaw);
        return;
      }

      // Add or move marker
      const pos = [lat, lon];
      if (!marker) {
        marker = L.marker(pos, { icon: ICONS[color] || ICONS.grey }).addTo(map);
        marker.bindPopup(`<b>Street Light</b><br>Status: ${status}`).openPopup();
        map.setView(pos, 16);
      } else {
        marker.setLatLng(pos);
        marker.setIcon(ICONS[color] || ICONS.grey);
        marker.getPopup().setContent(`<b>Street Light</b><br>Status: ${status}`);
      }
    } catch (err) {
      console.error("Fetch error:", err);
      document.getElementById("statustext").textContent = "Error fetching data";
    }
  }

  // Start polling
  fetchLatest();
  setInterval(fetchLatest, UPDATE_INTERVAL_MS);
  </script>
</body>
</html>

